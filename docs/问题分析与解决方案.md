# main.py问题分析与解决方案

## 问题总结

### 症状
- `main.py`运行后显示"主窗口显示成功"但程序立即退出
- `simple_main.py`能正常启动并保持运行

### 根本原因分析

#### 1. 对象引用管理问题
**原始main.py的错误做法：**
```python
# 使用异步回调创建窗口
def show_main_window():
    main_window = MainWindow()  # 局部变量
    main_window.show()
    return main_window

# 通过定时器调用，返回值没有被保持
QTimer.singleShot(1500, lambda: setattr(sys.modules[__name__], 'main_window', show_main_window()))
```

**问题：**
- 主窗口对象在回调函数作用域内创建
- 函数结束后，局部变量失去引用
- Python垃圾回收器可能回收窗口对象
- 导致窗口显示后立即消失

#### 2. 异步时序复杂性
**原始main.py：**
- 使用多个`QTimer.singleShot`创建复杂的异步调用链
- 主函数继续执行到`app.exec()`，但窗口还未创建完成
- 事件循环和窗口创建之间存在竞态条件

**simple_main.py的正确做法：**
```python
# 直接在主线程创建窗口
main_window = MainWindow()  # 主函数作用域变量
main_window.show()
app.exec()  # 窗口已创建完成，开始事件循环
```

#### 3. 启动画面管理问题
**原始问题：**
- `splash.finish(main_window)`可能影响窗口管理
- 启动画面和主窗口之间的交互复杂

## 解决方案

### 修复策略
1. **移除异步窗口创建**：改为同步直接创建
2. **简化启动画面逻辑**：使用简单的`time.sleep()`代替多个定时器
3. **确保正确的对象引用**：在主函数作用域创建窗口对象

### 修复后的main.py核心逻辑
```python
def main():
    # ... 初始化代码 ...
    
    # 创建启动画面
    splash = create_splash_screen()
    splash.show()
    app.processEvents()
    
    # 简单延迟
    time.sleep(1.0)
    
    # 直接创建主窗口（不使用异步回调）
    try:
        main_window = MainWindow()  # 主函数作用域，确保引用保持
        main_window.show()
        main_window.raise_()
        main_window.activateWindow()
        
        splash.close()  # 直接关闭启动画面
        logging.info("主窗口显示成功")
        
    except Exception as e:
        # 错误处理...
        return 1
    
    # 运行应用程序
    exit_code = app.exec()
    return exit_code
```

## 测试结果

### 修复前
```
2025-07-14 15:45:20,185 - root - INFO - 主窗口显示成功
2025-07-14 15:45:20,540 - root - INFO - 应用程序退出，退出码: 0
```
程序显示成功但立即退出。

### 修复后
```
2025-07-14 15:48:26,238 - root - INFO - 主窗口显示成功
2025-07-14 15:48:26,290 - root - INFO - 启动事件循环...
2025-07-14 15:48:26,929 - worker.waste_detection_worker - INFO - 摄像头初始化成功: 设备ID=0
2025-07-14 15:48:37,158 - ui.main_window - INFO - 应用程序正常关闭
```
程序正常启动、运行，并在用户关闭时正常退出。

## 经验总结

### 1. Qt应用程序窗口管理原则
- **保持对象引用**：确保主窗口对象在应用程序生命周期内有强引用
- **避免异步创建**：主窗口应在主线程同步创建
- **简化时序**：减少不必要的异步回调和定时器

### 2. Python对象生命周期
- 注意变量作用域，避免重要对象在局部作用域创建后失去引用
- 复杂的动态属性设置（如`setattr`）容易引入bug
- 简单直接的代码更可靠

### 3. 调试策略
- 对比工作版本和问题版本的核心差异
- 关注对象创建、引用和生命周期管理
- 使用日志追踪程序执行流程

## 最终状态

修复后的`main.py`保留了启动画面功能，但使用更简单可靠的窗口管理方式，解决了原有的对象引用和时序问题，现在能够与`simple_main.py`一样稳定运行。 